// Error types that can be passed directly into HAL responses

package errors

import (
	"errors"
	"fmt"
	"net/http"
	"reflect"
	"strings"

	"github.com/asaskevich/govalidator"
	"github.com/nvellon/hal"
)

// Common Errors
var (
	// Not Found Error
	NotFound = &Error{
		Code:    http.StatusNotFound,
		Message: "This is not the resource you are looking for",
	}
	// Internal Server Error
	ServerError = &Error{
		Code:    http.StatusInternalServerError,
		Message: "An unexpected error occurred",
	}
)

// A HAL error type that satisfies the nvellon/hal mapper interface
// and the standard go error interface, this allows us to produce
// hal formatted error responses
type Error struct {
	Code     int      `json:"code"`
	Message  string   `json:"message"`
	ErrorMap ErrorMap `json:"errors,omitempty"`
}

func (e *Error) Error() string {
	return e.Message
}

func (e *Error) GetMap() hal.Entry {
	return hal.Entry{"_errors": e}
}

// This type allows us to produce a map of specifc errors, this
// is useful for validation error messages for example where we
// need to list errors field by field
type ErrorMap map[string]string

func (m ErrorMap) Add(field string, err error) {
	m[field] = err.Error()
}

func (m ErrorMap) Delete(field string) {
	delete(m, field)
}

// Unauthorized
func Unauthorized(msg string, args ...interface{}) error {
	return &Error{
		Code:    http.StatusUnauthorized,
		Message: fmt.Sprintf(msg, args...),
	}
}

// errors.UnprocessableEntity(i, err)
func UnprocessableEntity(i interface{}, err error) error {
	return &Error{
		Code:     422,
		Message:  "Validation error",
		ErrorMap: ValidationErrorMap(i, err),
	}
}

// Constructs an ErrorMap from govalidator validation errors, if json tags also exist
// the error map will be populated with the json field name instead of the struct field name
func ValidationErrorMap(i interface{}, err error) ErrorMap {
	// Ensure we have a govalidator error
	err, ok := err.(govalidator.Errors)
	if !ok {
		return nil
	}

	// Use refect to get the raw struct element
	typ := reflect.TypeOf(i).Elem()
	if typ.Kind() != reflect.Struct {
		return nil
	}

	// Errors found by the validator
	errsByField := govalidator.ErrorsByField(err.(govalidator.Errors))

	// Make an error map
	m := make(ErrorMap, len(errsByField))

	// Loop over our struct fields
	for i := 0; i < typ.NumField(); i++ {
		// Get the field
		f := typ.Field(i)
		// Do we have an error for the field
		e, ok := errsByField[f.Name]
		if ok {
			// Try and get the `json` struct tag
			name := strings.Split(f.Tag.Get("json"), ",")[0]
			// If the name is - we should ignore the field
			if name == "-" {
				continue
			}
			// If the name is not blank we add it our error map
			if name != "" {
				m.Add(name, errors.New(e))
				continue
			}
			// Finall if all else has failed just add the raw field name to the
			// error map
			m.Add(f.Name, errors.New(e))
		}
	}

	return m
}
